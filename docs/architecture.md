# Conflux ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆæ›¸

## ç›®æ¬¡

1. [ã¯ã˜ã‚ã«](#ã¯ã˜ã‚ã«)
   - [ãªãœConfluxãŒå¿…è¦ãªã®ã‹](#ãªãœconfluxãŒå¿…è¦ãªã®ã‹)
   - [Confluxã¨ã¯](#confluxã¨ã¯)
   - [ã“ã®æ–‡æ›¸ã®æ§‹æˆ](#ã“ã®æ–‡æ›¸ã®æ§‹æˆ)
2. [ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å®šç¾©ã¨å½¹å‰²](#ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å®šç¾©ã¨å½¹å‰²)
   - [ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¨ã¯](#ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¨ã¯)
   - [ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å½¹å‰²](#ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å½¹å‰²)
3. [è¨­è¨ˆåŸå‰‡](#è¨­è¨ˆåŸå‰‡)
   - [ã‚·ãƒ³ãƒ—ãƒ«ãªè¨­è¨ˆ](#1-ã‚·ãƒ³ãƒ—ãƒ«ãªè¨­è¨ˆ)
   - [é€æ˜æ€§](#2-é€æ˜æ€§)
   - [ä¿¡é ¼æ€§](#3-ä¿¡é ¼æ€§)
   - [æ‹¡å¼µæ€§](#4-æ‹¡å¼µæ€§)
4. [ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®æ§‹æˆè¦ç´ ](#ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®æ§‹æˆè¦ç´ )
   - [ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦](#ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦)
   - [ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¨ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ï¼ˆACIï¼‰](#ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¨ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹aci)
5. [ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å®Ÿè£…æ‰‹æ³•](#ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å®Ÿè£…æ‰‹æ³•)
   - [ThinkingOrchestratorï¼ˆæ€è€ƒã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼‰](#1-thinkingorchestratoræ€è€ƒã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼)
   - [BaseThinkingAgentï¼ˆãƒ™ãƒ¼ã‚¹ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼‰](#2-basethinkingagentãƒ™ãƒ¼ã‚¹ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ)
   - [LLMProviderï¼ˆLLMãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ï¼‰](#3-llmproviderllmãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼)
6. [ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è©•ä¾¡ã¨æ”¹å–„](#ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è©•ä¾¡ã¨æ”¹å–„)
   - [ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è©•ä¾¡æŒ‡æ¨™](#ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è©•ä¾¡æŒ‡æ¨™)
   - [è©•ä¾¡ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…](#è©•ä¾¡ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…)
   - [æ€è€ƒæ³•ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ](#æ€è€ƒæ³•ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ)
7. [æ€è€ƒæˆ¦ç•¥](#æ€è€ƒæˆ¦ç•¥)
   - [å±€é¢åˆ¥æˆ¦ç•¥ãƒãƒƒãƒ”ãƒ³ã‚°](#å±€é¢åˆ¥æˆ¦ç•¥ãƒãƒƒãƒ”ãƒ³ã‚°)
   - [é»„é‡‘ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆGolden Patternï¼‰](#é»„é‡‘ãƒ‘ã‚¿ãƒ¼ãƒ³golden-pattern)
8. [å‹å®‰å…¨æ€§ã¨ã‚¹ã‚­ãƒ¼ãƒè¨­è¨ˆ](#å‹å®‰å…¨æ€§ã¨ã‚¹ã‚­ãƒ¼ãƒè¨­è¨ˆ)
   - [ã‚¹ã‚­ãƒ¼ãƒè¨­è¨ˆã®åŸå‰‡](#ã‚¹ã‚­ãƒ¼ãƒè¨­è¨ˆã®åŸå‰‡)
   - [åŸºæœ¬å‹å®šç¾©](#åŸºæœ¬å‹å®šç¾©)
   - [æ€è€ƒçµæœã®å‹å®šç¾©](#æ€è€ƒçµæœã®å‹å®šç¾©)
   - [å„æ€è€ƒæ³•ã®ã‚¹ã‚­ãƒ¼ãƒ](#å„æ€è€ƒæ³•ã®ã‚¹ã‚­ãƒ¼ãƒ)
9. [MCPçµ±åˆ](#mcpçµ±åˆ)
   - [MCPã‚µãƒ¼ãƒãƒ¼è¨­è¨ˆ](#mcpã‚µãƒ¼ãƒãƒ¼è¨­è¨ˆ)
10. [CLIè¨­è¨ˆ](#cliè¨­è¨ˆ)
    - [ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹](#ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹)
11. [å“è³ªä¿è¨¼](#å“è³ªä¿è¨¼)
    - [å‹å®‰å…¨æ€§ã®ç¢ºä¿](#å‹å®‰å…¨æ€§ã®ç¢ºä¿)
    - [ãƒ†ã‚¹ãƒˆæˆ¦ç•¥](#ãƒ†ã‚¹ãƒˆæˆ¦ç•¥)
12. [æ‹¡å¼µæ€§](#æ‹¡å¼µæ€§)
    - [ã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è¿½åŠ ](#ã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è¿½åŠ )
    - [æ–°è¦ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã®è¿½åŠ ](#æ–°è¦ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã®è¿½åŠ )
13. [ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¨ä¿¡é ¼æ€§](#ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¨ä¿¡é ¼æ€§)
    - [ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–](#ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–)
    - [ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°](#ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°)
14. [ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£](#ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£)
    - [APIã‚­ãƒ¼ç®¡ç†](#apiã‚­ãƒ¼ç®¡ç†)
    - [ãƒ‡ãƒ¼ã‚¿å‡¦ç†](#ãƒ‡ãƒ¼ã‚¿å‡¦ç†)
15. [Dockerç’°å¢ƒã§ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£](#dockerç’°å¢ƒã§ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£)
    - [ã‚³ãƒ³ãƒ†ãƒŠåŒ–æˆ¦ç•¥](#ã‚³ãƒ³ãƒ†ãƒŠåŒ–æˆ¦ç•¥)
    - [ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³](#ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³)
    - [ãƒ­ã‚°ã¨ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°](#ãƒ­ã‚°ã¨ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°)
16. [ä»˜éŒ²](#ä»˜éŒ²)
    - [ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿéš›ã®ä½¿ç”¨ä¾‹](#ä»˜éŒ²1-ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿéš›ã®ä½¿ç”¨ä¾‹)
    - [ãƒ„ãƒ¼ãƒ«ã®è¨­è¨ˆã¨çµ±åˆ](#ä»˜éŒ²2-ãƒ„ãƒ¼ãƒ«ã®è¨­è¨ˆã¨çµ±åˆ)
    - [å®Ÿè£…ã‚¬ã‚¤ãƒ‰](#ä»˜éŒ²3-å®Ÿè£…ã‚¬ã‚¤ãƒ‰)
17. [ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°](#ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°)
    - [ã‚ˆãã‚ã‚‹å•é¡Œã¨è§£æ±ºæ–¹æ³•](#ã‚ˆãã‚ã‚‹å•é¡Œã¨è§£æ±ºæ–¹æ³•)
    - [ãƒ‡ãƒãƒƒã‚°ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹](#ãƒ‡ãƒãƒƒã‚°ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹)
    - [ã‚µãƒãƒ¼ãƒˆã¨ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£](#ã‚µãƒãƒ¼ãƒˆã¨ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£)
18. [ä»Šå¾Œã®æ‹¡å¼µæ–¹å‘](#ä»Šå¾Œã®æ‹¡å¼µæ–¹å‘)

---

## ã¯ã˜ã‚ã«

### ãªãœConfluxãŒå¿…è¦ãªã®ã‹

ç¾ä»£ã®ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢é–‹ç™ºã§ã¯ã€è¤‡é›‘ãªå•é¡Œã‚’è§£æ±ºã™ã‚‹ãŸã‚ã«å¤šè§’çš„ãªæ€è€ƒãŒæ±‚ã‚ã‚‰ã‚Œã¾ã™ã€‚ã—ã‹ã—ã€äººé–“ã®èªçŸ¥èƒ½åŠ›ã«ã¯é™ç•ŒãŒã‚ã‚Šã€ä¸€ã¤ã®æ€è€ƒãƒ‘ã‚¿ãƒ¼ãƒ³ã«åã‚ŠãŒã¡ã§ã™ã€‚Confluxã¯ã€ã“ã®èª²é¡Œã‚’è§£æ±ºã™ã‚‹ãŸã‚ã«è¨­è¨ˆã•ã‚ŒãŸãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚

### Confluxã¨ã¯

Confluxã¯ã€9ã¤ã®æ§‹é€ åŒ–ã•ã‚ŒãŸæ€è€ƒæ³•ã‚’çµ„ã¿åˆã‚ã›ãŸãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç‰¹å®šã®æ€è€ƒãƒ‘ã‚¿ãƒ¼ãƒ³ã«ç‰¹åŒ–ã—ã€é–‹ç™ºãƒ—ãƒ­ã‚»ã‚¹ã®å„å±€é¢ã§æœ€é©ãªæ€è€ƒæ”¯æ´ã‚’æä¾›ã—ã¾ã™ã€‚

**ä¸»ãªç‰¹å¾´**:
- **9ã¤ã®æ€è€ƒæ³•**: ã‚¢ãƒ–ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ã€ãƒ­ã‚¸ã‚«ãƒ«ã€ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã€MECEã€æ¼”ç¹¹ã€å¸°ç´ã€PACã€ãƒ¡ã‚¿ã€ãƒ‡ã‚£ãƒ™ãƒ¼ãƒˆ
- **å±€é¢åˆ¥æœ€é©åŒ–**: 15ã®é–‹ç™ºå±€é¢ã«å¿œã˜ãŸæ€è€ƒæˆ¦ç•¥
- **é€æ˜æ€§**: æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ã®å®Œå…¨ãªå¯è¦–åŒ–
- **ä¿¡é ¼æ€§**: ä¸€è²«ã—ãŸçµæœã¨è‡ªå‹•å¾©æ—§æ©Ÿèƒ½
- **æ‹¡å¼µæ€§**: æ–°ã—ã„æ€è€ƒæ³•ã®å®¹æ˜“ãªè¿½åŠ 

**ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸å**: @53able/conflux  
**ãƒªãƒã‚¸ãƒˆãƒª**: https://github.com/53able/conflux  
**æœ€æ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: [GitHub Releases](https://github.com/53able/conflux/releases)ã‚’å‚ç…§

### ã“ã®æ–‡æ›¸ã®æ§‹æˆ

ã“ã®æ–‡æ›¸ã§ã¯ã€Confluxã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’æ®µéšçš„ã«èª¬æ˜ã—ã¾ã™ï¼š
1. **ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å®šç¾©ã¨å½¹å‰²**: ã‚·ã‚¹ãƒ†ãƒ ã®åŸºæœ¬æ¦‚å¿µ
2. **è¨­è¨ˆåŸå‰‡**: 4ã¤ã®ä¸»è¦ãªè¨­è¨ˆåŸå‰‡
3. **ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®æ§‹æˆè¦ç´ **: ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®è©³ç´°
4. **ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å®Ÿè£…æ‰‹æ³•**: å…·ä½“çš„ãªå®Ÿè£…æ–¹æ³•
5. **ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è©•ä¾¡ã¨æ”¹å–„**: æ€§èƒ½è©•ä¾¡ã¨æ”¹å–„æ–¹æ³•
6. **ä»˜éŒ²**: å®Ÿéš›ã®ä½¿ç”¨ä¾‹ã¨ãƒ„ãƒ¼ãƒ«è¨­è¨ˆã‚¬ã‚¤ãƒ‰

## ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å®šç¾©ã¨å½¹å‰²

### ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¨ã¯

Confluxã«ãŠã‘ã‚‹ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ã€ç‰¹å®šã®æ€è€ƒãƒ‘ã‚¿ãƒ¼ãƒ³ã«ç‰¹åŒ–ã—ãŸç‹¬ç«‹ã—ãŸã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã§ã™ã€‚å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯æ˜ç¢ºãªå…¥åŠ›ãƒ»å‡ºåŠ›ã‚’æŒã¡ã€äºˆæ¸¬å¯èƒ½ãªå‹•ä½œã‚’ä¿è¨¼ã—ã¾ã™ã€‚

**ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ç‰¹å¾´**:
- **ç‰¹åŒ–æ€§**: ä¸€ã¤ã®æ€è€ƒæ³•ã«é›†ä¸­ã—ã€ãã®é ˜åŸŸã§æœ€é«˜ã®æ€§èƒ½ã‚’ç™ºæ®
- **ç‹¬ç«‹æ€§**: ä»–ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«ä¾å­˜ã›ãšã€å˜ç‹¬ã§å‹•ä½œå¯èƒ½
- **ä¸€è²«æ€§**: åŒã˜å…¥åŠ›ã«å¯¾ã—ã¦å¸¸ã«åŒã˜å½¢å¼ã®å‡ºåŠ›ã‚’ç”Ÿæˆ
- **é€æ˜æ€§**: æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ã®å„ã‚¹ãƒ†ãƒƒãƒ—ã‚’æ˜ç¢ºã«è¨˜éŒ²

### ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å½¹å‰²

#### 1. æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ã®æ¨™æº–åŒ–

å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ã€ç‰¹å®šã®æ€è€ƒæ³•ã®å®Ÿè¡Œãƒ•ãƒ­ãƒ¼ã‚’æ¨™æº–åŒ–ã—ã¾ã™ï¼š

```typescript
// æ¨™æº–çš„ãªæ€è€ƒãƒ—ãƒ­ã‚»ã‚¹
async think(input: unknown, context: AgentContext): Promise<ThinkingResult> {
  // 1. å…¥åŠ›æ¤œè¨¼
  // 2. å‰å‡¦ç†
  // 3. LLMå®Ÿè¡Œï¼ˆæ€è€ƒæ³•å›ºæœ‰ã®ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
  // 4. å¾Œå‡¦ç†
  // 5. çµæœè¿”å´
}
```

#### 2. é€æ˜æ€§ã®æä¾›

ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ã®å„ã‚¹ãƒ†ãƒƒãƒ—ã‚’å¯è¦–åŒ–ã—ã¾ã™ï¼š

- **å…¥åŠ›ã®åˆ†æ**: ã©ã®ã‚ˆã†ãªæƒ…å ±ãŒä¸ãˆã‚‰ã‚ŒãŸã‹
- **æ€è€ƒã®éç¨‹**: ã©ã®ã‚ˆã†ãªæ¨è«–ã‚’è¡Œã£ãŸã‹
- **çµè«–ã®æ ¹æ‹ **: ãªãœãã®çµè«–ã«è‡³ã£ãŸã‹
- **æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—**: æ¨å¥¨ã•ã‚Œã‚‹æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³

#### 3. ä¿¡é ¼æ€§ã®ç¢ºä¿

ä¸€è²«ã—ãŸçµæœã¨ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’æä¾›ã—ã¾ã™ï¼š

- **å‹å®‰å…¨æ€§**: TypeScriptã¨Zodã«ã‚ˆã‚‹å³å¯†ãªå‹ãƒã‚§ãƒƒã‚¯
- **è‡ªå‹•å¾©æ—§**: LLMå‘¼ã³å‡ºã—ã®å¤±æ•—æ™‚ã®è‡ªå‹•å†è©¦è¡Œ
- **ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°**: å•é¡Œã®åŸå› ã¨è§£æ±ºæ–¹æ³•ã®è©³ç´°è¨˜éŒ²

#### 4. æ‹¡å¼µæ€§ã®å®Ÿç¾

æ–°ã—ã„æ€è€ƒæ³•ã®å®¹æ˜“ãªè¿½åŠ ã‚’å¯èƒ½ã«ã—ã¾ã™ï¼š

- **çµ±ä¸€ã•ã‚ŒãŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹**: ä¸€è²«ã—ãŸå®Ÿè£…æ–¹æ³•
- **ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£**: æ—¢å­˜ã‚·ã‚¹ãƒ†ãƒ ã¸ã®å½±éŸ¿ãªã—
- **ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆåŒ–ã•ã‚ŒãŸAPI**: æ‹¡å¼µã®ãŸã‚ã®æ˜ç¢ºãªã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

## è¨­è¨ˆåŸå‰‡

Confluxã¯ã€Building effective agentsã®åŸå‰‡ã«åŸºã¥ã„ã¦è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚ä»¥ä¸‹ã®4ã¤ã®åŸå‰‡ãŒã€ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®è¨­è¨ˆæŒ‡é‡ã¨ãªã£ã¦ã„ã¾ã™ã€‚

### 1. ã‚·ãƒ³ãƒ—ãƒ«ãªè¨­è¨ˆ

**åŸå‰‡**: è¤‡é›‘ã•ã‚’æ’é™¤ã—ã€æœ¬è³ªçš„ãªæ©Ÿèƒ½ã«é›†ä¸­ã™ã‚‹

**å®Ÿè£…ä¾‹**:
```typescript
// è¤‡é›‘ãªè¨­å®šã‚’é¿ã‘ã€å¿…è¦æœ€å°é™ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ã¿
interface AgentConfig {
  methodType: ThinkingMethodType;
  llmProvider: string;
  timeout?: number;
}

// æ˜ç¢ºãªè²¬å‹™åˆ†é›¢ - å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯å˜ä¸€ã®æ€è€ƒæ³•ã«ç‰¹åŒ–
class AbductionAgent extends BaseThinkingAgent {
  readonly capability: AgentCapability = {
    methodType: 'abduction',
    description: 'é©šãã®äº‹å®Ÿã‹ã‚‰æœ€å°¤èª¬æ˜ä»®èª¬ã‚’å½¢æˆ',
    applicablePhases: ['business_exploration', 'debugging'],
    requiredInputSchema: AbductionInput,
    outputSchema: AbductionOutput,
    combinationSynergies: ['deductive', 'inductive', 'critical']
  };

  // ã‚¢ãƒ–ãƒ€ã‚¯ã‚·ãƒ§ãƒ³æ€è€ƒã®ã¿ã«ç‰¹åŒ–ã—ãŸå®Ÿè£…
  protected async executeLLMThinking(input: unknown, context: AgentContext) {
    // é©šãã®äº‹å®Ÿã‹ã‚‰ä»®èª¬ã‚’ç”Ÿæˆã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯
    return await this.generateHypotheses(input, context);
  }
}
```

**åŠ¹æœ**:
- å­¦ç¿’ã‚³ã‚¹ãƒˆã®å‰Šæ¸›
- ãƒ‡ãƒãƒƒã‚°ã®å®¹æ˜“ã•
- ä¿å®ˆæ€§ã®å‘ä¸Š

### 2. é€æ˜æ€§

**åŸå‰‡**: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å‹•ä½œã‚’å®Œå…¨ã«å¯è¦–åŒ–ã™ã‚‹

**å®Ÿè£…ä¾‹**:
```typescript
// æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ã®è©³ç´°ãƒ­ã‚°ã¨è¿½è·¡
const result = await agent.think(input, {
  llmProvider: globalLLMManager.getProvider(),
  sessionId: 'debug-session-001',
  metadata: {
    logLevel: 'detailed',
    includeReasoning: true,
    trackSteps: true
  }
});

// å®Ÿéš›ã®å‡ºåŠ›ä¾‹ï¼ˆAbductionAgentã®å ´åˆï¼‰
{
  method: 'abduction',
  status: 'completed',
  input: {
    surprisingFact: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ­ã‚°ã‚¤ãƒ³ã§ããªã„',
    context: 'ãƒ¢ãƒã‚¤ãƒ«ã‚¢ãƒ—ãƒªã§ç™ºç”Ÿ',
    domain: 'èªè¨¼ã‚·ã‚¹ãƒ†ãƒ '
  },
  output: {
    hypotheses: [
      {
        explanation: 'èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ã®æœŸé™åˆ‡ã‚Œ',
        plausibility: 0.8,
        testablePredictions: ['ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æœŸé™ã‚’ç¢ºèª', 'å†èªè¨¼ãƒ•ãƒ­ãƒ¼ã‚’ãƒ†ã‚¹ãƒˆ']
      }
    ],
    recommendedNext: ['deductive', 'critical']
  },
  confidence: 0.8,
  reasoning: 'è¦³å¯Ÿã•ã‚ŒãŸäº‹å®Ÿã‹ã‚‰æœ€ã‚‚å¯èƒ½æ€§ã®é«˜ã„èª¬æ˜ã‚’ç”Ÿæˆ',
  metadata: {
    executionTime: 1250,
    timestamp: '2024-01-15T10:30:00Z',
    llmProvider: 'openai',
    model: 'gpt-4o'
  }
}
```

**åŠ¹æœ**:
- ãƒ‡ãƒãƒƒã‚°ã®åŠ¹ç‡åŒ–
- ä¿¡é ¼æ€§ã®å‘ä¸Š
- å­¦ç¿’åŠ¹æœã®ä¿ƒé€²

### 3. ä¿¡é ¼æ€§

**åŸå‰‡**: ä¸€è²«ã—ãŸçµæœã¨äºˆæ¸¬å¯èƒ½ãªå‹•ä½œã‚’ä¿è¨¼ã™ã‚‹

**å®Ÿè£…ä¾‹**:
```typescript
// è‡ªå‹•å¾©æ—§æ©Ÿèƒ½ä»˜ãLLMå‘¼ã³å‡ºã—ï¼ˆå®Ÿéš›ã®å®Ÿè£…ï¼‰
protected async callLLMWithStructuredOutput<T>(
  schema: ZodSchema<T>,
  systemPrompt: string,
  userPrompt: string,
  context: AgentContext,
  options?: {
    temperature?: number;
    maxRetries?: number;
    enableAutoRecovery?: boolean;
  }
): Promise<T> {
  const maxRetries = options?.maxRetries ?? 3;
  let lastError: Error | null = null;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      // AI SDKã®generateObjectã‚’ä½¿ç”¨ï¼ˆã‚¹ã‚­ãƒ¼ãƒä¿è¨¼ï¼‰
      const result = await generateObject({
        model: context.llmProvider as LanguageModel,
        schema,
        system: systemPrompt,
        prompt: userPrompt,
        temperature: options?.temperature ?? 0.3,
        mode: 'json'
      });
      
      return result.object as T;
    } catch (error) {
      lastError = error instanceof Error ? error : new Error('Unknown error');
      this.logger.warn('LLM generation attempt failed', {
        attempt,
        maxRetries,
        error: lastError.message
      });
      
      if (attempt < maxRetries) {
        // æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã§å†è©¦è¡Œ
        await this.sleep(Math.pow(2, attempt) * 1000);
      }
    }
  }
  
  throw new Error(`LLM generation failed after ${maxRetries} attempts: ${lastError?.message}`);
}
```

**åŠ¹æœ**:
- ã‚·ã‚¹ãƒ†ãƒ ã®å®‰å®šæ€§
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã®å‘ä¸Š
- é‹ç”¨ã‚³ã‚¹ãƒˆã®å‰Šæ¸›

### 4. æ‹¡å¼µæ€§

**åŸå‰‡**: æ–°ã—ã„æ€è€ƒæ³•ã®å®¹æ˜“ãªè¿½åŠ ã‚’å¯èƒ½ã«ã™ã‚‹

**å®Ÿè£…ä¾‹**:
```typescript
// ã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è¿½åŠ 
class CustomThinkingAgent extends BaseThinkingAgent {
  readonly capability: AgentCapability = {
    methodType: 'custom',
    description: 'ã‚«ã‚¹ã‚¿ãƒ æ€è€ƒæ³•',
    applicablePhases: ['implementation'],
    requiredInputSchema: z.object({
      problem: z.string(),
      context: z.string().optional()
    }),
    outputSchema: z.object({
      solution: z.string(),
      confidence: z.number().min(0).max(1)
    })
  };
  
  protected async executeLLMThinking(input: unknown, context: AgentContext) {
    // ã‚«ã‚¹ã‚¿ãƒ ãƒ­ã‚¸ãƒƒã‚¯ã®å®Ÿè£…
  }
}

// ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ç™»éŒ²
orchestrator.registerAgent(new CustomThinkingAgent());
```

**åŠ¹æœ**:
- ã‚·ã‚¹ãƒ†ãƒ ã®æŸ”è»Ÿæ€§
- å°†æ¥ã®æ‹¡å¼µã¸ã®å¯¾å¿œ
- ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã®å®¹æ˜“ã•

## ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®æ§‹æˆè¦ç´ 

### ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦

Confluxã¯3å±¤ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã§æ§‹æˆã•ã‚Œã€å„å±¤ãŒæ˜ç¢ºãªè²¬å‹™ã‚’æŒã¡ã¾ã™ï¼š

```mermaid
graph TB
    subgraph "ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å±¤ (Interface Layer)"
        CLI["ğŸ–¥ï¸ CLI Interface<br/>ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³æ“ä½œ"]
        MCP["ğŸ”Œ MCP Server<br/>AIé–‹ç™ºç’°å¢ƒçµ±åˆ"]
        LIB["ğŸ“š Library API<br/>ãƒ—ãƒ­ã‚°ãƒ©ãƒ åˆ©ç”¨"]
    end
    
    subgraph "ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå±¤ (Agent Layer)"
        ORCH["ğŸ¯ ThinkingOrchestrator<br/>æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹çµ±åˆç®¡ç†"]
        
        subgraph "æ€è€ƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç¾¤ (Thinking Agents)"
            ABD["ğŸ” AbductionAgent<br/>ä»®èª¬å½¢æˆ"]
            LOG["ğŸ§  LogicalAgent<br/>è«–ç†æ§‹ç¯‰"]
            CRIT["âš¡ CriticalAgent<br/>æ‰¹åˆ¤çš„æ¤œè¨¼"]
            MECE["ğŸ“Š MECEAgent<br/>åˆ†é¡æ•´ç†"]
            DED["ğŸ“ DeductiveAgent<br/>æ¼”ç¹¹æ¨è«–"]
            IND["ğŸ“ˆ InductiveAgent<br/>å¸°ç´åˆ†æ"]
            PAC["ğŸ”¬ PACAgent<br/>æ§‹é€ åˆ†è§£"]
            META["ğŸ”„ MetaAgent<br/>ãƒ¡ã‚¿æ€è€ƒ"]
            DEBATE["âš–ï¸ DebateAgent<br/>å¯¾ç«‹æ¤œè¨"]
        end
    end
    
    subgraph "åŸºç›¤å±¤ (Foundation Layer)"
        BASE["ğŸ—ï¸ BaseThinkingAgent<br/>å…±é€šåŸºç›¤ã‚¯ãƒ©ã‚¹"]
        LLM["ğŸ¤– LLMProvider<br/>AIçµ±åˆç®¡ç†"]
        SCHEMA["ğŸ“‹ SchemaRegistry<br/>å‹å®‰å…¨æ€§ä¿è¨¼"]
        LOGGER["ğŸ“ Logger<br/>ãƒ­ã‚°ç®¡ç†"]
    end
    
    %% ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å±¤ã‹ã‚‰ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå±¤ã¸ã®æ¥ç¶š
    CLI -->|"å±€é¢åˆ¥æ€è€ƒå®Ÿè¡Œ"| ORCH
    MCP -->|"MCPãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—"| ORCH
    LIB -->|"ãƒ—ãƒ­ã‚°ãƒ©ãƒ åˆ©ç”¨"| ORCH
    
    %% ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼ã‹ã‚‰å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¸ã®æ¥ç¶š
    ORCH -->|"æ€è€ƒæ³•å®Ÿè¡Œ"| ABD
    ORCH -->|"æ€è€ƒæ³•å®Ÿè¡Œ"| LOG
    ORCH -->|"æ€è€ƒæ³•å®Ÿè¡Œ"| CRIT
    ORCH -->|"æ€è€ƒæ³•å®Ÿè¡Œ"| MECE
    ORCH -->|"æ€è€ƒæ³•å®Ÿè¡Œ"| DED
    ORCH -->|"æ€è€ƒæ³•å®Ÿè¡Œ"| IND
    ORCH -->|"æ€è€ƒæ³•å®Ÿè¡Œ"| PAC
    ORCH -->|"æ€è€ƒæ³•å®Ÿè¡Œ"| META
    ORCH -->|"æ€è€ƒæ³•å®Ÿè¡Œ"| DEBATE
    
    %% å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‹ã‚‰åŸºç›¤å±¤ã¸ã®æ¥ç¶š
    ABD -->|"ç¶™æ‰¿"| BASE
    LOG -->|"ç¶™æ‰¿"| BASE
    CRIT -->|"ç¶™æ‰¿"| BASE
    MECE -->|"ç¶™æ‰¿"| BASE
    DED -->|"ç¶™æ‰¿"| BASE
    IND -->|"ç¶™æ‰¿"| BASE
    PAC -->|"ç¶™æ‰¿"| BASE
    META -->|"ç¶™æ‰¿"| BASE
    DEBATE -->|"ç¶™æ‰¿"| BASE
    
    %% åŸºç›¤å±¤å†…éƒ¨ã®æ¥ç¶š
    BASE -->|"LLMå‘¼ã³å‡ºã—"| LLM
    BASE -->|"å‹æ¤œè¨¼"| SCHEMA
    BASE -->|"ãƒ­ã‚°å‡ºåŠ›"| LOGGER
    
    %% ã‚¹ã‚¿ã‚¤ãƒªãƒ³ã‚°
    classDef interfaceLayer fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    classDef agentLayer fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    classDef foundationLayer fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px
    classDef orchestrator fill:#fff3e0,stroke:#e65100,stroke-width:3px
    
    class CLI,MCP,LIB interfaceLayer
    class ABD,LOG,CRIT,MECE,DED,IND,PAC,META,DEBATE agentLayer
    class BASE,LLM,SCHEMA,LOGGER foundationLayer
    class ORCH orchestrator
```

### ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¨ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ï¼ˆACIï¼‰

å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ä»¥ä¸‹ã®æ¨™æº–ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§å‹•ä½œã—ã¾ã™ï¼š

```typescript
interface IThinkingAgent {
  readonly capability: AgentCapability;
  think(input: unknown, context: AgentContext): Promise<ThinkingResult>;
}
```

ã“ã®è¨­è¨ˆã«ã‚ˆã‚Šã€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å‹•ä½œãŒäºˆæ¸¬å¯èƒ½ã§ã€ãƒ‡ãƒãƒƒã‚°ã¨ãƒ†ã‚¹ãƒˆãŒå®¹æ˜“ã«ãªã‚Šã¾ã™ã€‚

## ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å®Ÿè£…æ‰‹æ³•

### 1. ThinkingOrchestratorï¼ˆæ€è€ƒã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼‰

**ç›®çš„**: è¤‡æ•°ã®æ€è€ƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’çµ±åˆã—ã€é–‹ç™ºå±€é¢ã«å¿œã˜ãŸæœ€é©ãªæ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ã‚’å®Ÿè¡Œ

**å®Ÿè£…ã®é€æ˜æ€§**:
- å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®èƒ½åŠ›ã‚’æ˜ç¢ºã«å®šç¾©
- æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ã®å„ã‚¹ãƒ†ãƒƒãƒ—ã‚’è¿½è·¡å¯èƒ½
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨å¾©æ—§æˆ¦ç•¥ã‚’æ˜ç¤º

**ä¸»è¦æ©Ÿèƒ½ã®å®Ÿè£…**:
```typescript
class ThinkingOrchestrator {
  private agents: Map<ThinkingMethodType, IThinkingAgent> = new Map();
  private phaseStrategyMap: Map<DevelopmentPhase, ThinkingStrategy> = new Map();

  // å±€é¢åˆ¥æ€è€ƒæˆ¦ç•¥ã®å®Ÿè¡Œ
  async processPhase(phase: DevelopmentPhase, input: unknown): Promise<IntegratedThinkingResult> {
    const strategy = this.phaseStrategyMap.get(phase);
    if (!strategy) {
      throw new Error(`No strategy defined for phase: ${phase}`);
    }

    const results: ThinkingResult[] = [];
    
    // ä¸»è¦æ€è€ƒæ³•ã®å®Ÿè¡Œ
    const primaryResult = await this.executeAgent(strategy.primaryMethod, input);
    results.push(primaryResult);

    // ä½µç”¨æ€è€ƒæ³•ã®ä¸¦åˆ—å®Ÿè¡Œ
    const secondaryResults = await Promise.all(
      strategy.secondaryMethods.map(method => 
        this.executeAgent(method, input)
      )
    );
    results.push(...secondaryResults);

    // çµæœã®çµ±åˆ
    return this.synthesizeResults(phase, results);
  }

  // é»„é‡‘ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆæ¢ç´¢â†’å®Ÿè£…ï¼‰ã®å®Ÿè¡Œ
  async processGoldenPattern(input: unknown): Promise<IntegratedThinkingResult> {
    const sequence = ['abduction', 'deductive', 'inductive', 'critical', 'logical', 'meta', 'debate'];
    const results: ThinkingResult[] = [];
    let currentInput = input;

    for (const method of sequence) {
      const result = await this.executeAgent(method as ThinkingMethodType, currentInput);
      results.push(result);
      currentInput = result.output; // æ¬¡ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å…¥åŠ›ã¨ã—ã¦ä½¿ç”¨
    }

    return this.synthesizeResults('golden_pattern', results);
  }

  // å˜ä¸€æ€è€ƒæ³•ã®å®Ÿè¡Œ
  async processSingleMethod(method: ThinkingMethodType, input: unknown): Promise<ThinkingResult> {
    return await this.executeAgent(method, input);
  }

  private async executeAgent(method: ThinkingMethodType, input: unknown): Promise<ThinkingResult> {
    const agent = this.agents.get(method);
    if (!agent) {
      throw new Error(`Agent not found: ${method}`);
    }

    try {
      return await agent.think(input, { methodType: method });
    } catch (error) {
      this.logger.error(`Agent execution failed: ${method}`, error);
      throw error;
    }
  }
}
```

**ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç®¡ç†**:
- å„æ€è€ƒæ³•ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ç™»éŒ²ãƒ»ç®¡ç†
- ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–“ã®ä¾å­˜é–¢ä¿‚ã®è§£æ±º
- ä¸¦åˆ—å®Ÿè¡Œå¯èƒ½ãªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ç‰¹å®š

### 2. BaseThinkingAgentï¼ˆãƒ™ãƒ¼ã‚¹ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼‰

**ç›®çš„**: å…¨æ€è€ƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å…±é€šåŸºç›¤ã‚’æä¾›ã—ã€ä¸€è²«ã—ãŸå‹•ä½œã‚’ä¿è¨¼

**å®Ÿè£…åŸå‰‡**:
- å˜ä¸€ã®è²¬ä»»ï¼šæ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ã®æ¨™æº–åŒ–
- æ˜ç¢ºãªã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ï¼šäºˆæ¸¬å¯èƒ½ãªå‹•ä½œ
- è‡ªå‹•å¾©æ—§ï¼šLLMå‘¼ã³å‡ºã—ã®ä¿¡é ¼æ€§å‘ä¸Š

**Template Methodãƒ‘ã‚¿ãƒ¼ãƒ³ã®å®Ÿè£…**:
```typescript
abstract class BaseThinkingAgent implements IThinkingAgent {
  constructor(
    protected llmProvider: LLMProvider,
    protected logger: Logger,
    public readonly capability: AgentCapability
  ) {}

  // æ¨™æº–æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ï¼ˆå¤‰æ›´ä¸å¯ï¼‰
  async think(input: unknown, context: AgentContext): Promise<ThinkingResult> {
    const startTime = Date.now();
    
    try {
      // 1. å…¥åŠ›æ¤œè¨¼
      const validatedInput = this.validateInput(input);
      
      // 2. å‰å‡¦ç†
      const processedInput = await this.preprocess(validatedInput, context);
      
      // 3. LLMå®Ÿè¡Œï¼ˆã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§å®Ÿè£…ï¼‰
      const llmOutput = await this.executeLLMThinking(processedInput, context);
      
      // 4. å¾Œå‡¦ç†
      const processedOutput = await this.postprocess(llmOutput, context);
      
      // 5. çµæœè¿”å´
      return {
        method: this.capability.methodType,
        status: 'completed',
        input: validatedInput,
        output: processedOutput,
        confidence: this.calculateConfidence(processedOutput),
        reasoning: this.generateReasoning(processedInput, processedOutput),
        metadata: {
          executionTime: Date.now() - startTime,
          timestamp: new Date().toISOString()
        }
      };
    } catch (error) {
      this.logger.error(`Agent execution failed: ${this.capability.methodType}`, error);
      return {
        method: this.capability.methodType,
        status: 'failed',
        input,
        confidence: 0,
        reasoning: `Error: ${error.message}`,
        metadata: { error: error.message }
      };
    }
  }

  // ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§å®Ÿè£…ï¼ˆå„æ€è€ƒæ³•ã®å›ºæœ‰ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
  protected abstract executeLLMThinking(input: unknown, context: AgentContext): Promise<Record<string, unknown>>;

  // å…±é€šã®å‰å‡¦ç†
  protected async preprocess(input: unknown, context: AgentContext): Promise<unknown> {
    // å…¥åŠ›ã®æ­£è¦åŒ–ã‚„å¤‰æ›
    return input;
  }

  // å…±é€šã®å¾Œå‡¦ç†
  protected async postprocess(output: Record<string, unknown>, context: AgentContext): Promise<Record<string, unknown>> {
    // å‡ºåŠ›ã®æ¤œè¨¼ã‚„å¤‰æ›
    return this.capability.outputSchema.parse(output);
  }

  // å…¥åŠ›æ¤œè¨¼
  protected validateInput(input: unknown): unknown {
    return this.capability.requiredInputSchema.parse(input);
  }

  // ä¿¡é ¼åº¦ã®è¨ˆç®—
  protected calculateConfidence(output: Record<string, unknown>): number {
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ä¿¡é ¼åº¦è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯
    return 0.8;
  }

  // æ¨è«–éç¨‹ã®ç”Ÿæˆ
  protected generateReasoning(input: unknown, output: Record<string, unknown>): string {
    return `Applied ${this.capability.methodType} thinking to analyze the input and generate the output.`;
  }
}
```

**ä¿¡é ¼æ€§ã®ç¢ºä¿**:
- è‡ªå‹•å¾©æ—§æ©Ÿèƒ½ä»˜ãLLMå‘¼ã³å‡ºã—
- ã‚¹ã‚­ãƒ¼ãƒæ¤œè¨¼ã«ã‚ˆã‚‹å‹å®‰å…¨æ€§
- è©³ç´°ãªã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã¨ãƒ‡ãƒãƒƒã‚°æƒ…å ±

### 3. LLMProviderï¼ˆLLMãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ï¼‰

**ç›®çš„**: è¤‡æ•°ã®LLMãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã‚’çµ±ä¸€çš„ã«ç®¡ç†ã—ã€ä¿¡é ¼æ€§ã®é«˜ã„LLMå‘¼ã³å‡ºã—ã‚’æä¾›

**å¯¾å¿œãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼**:
- OpenAI (GPT-4o, GPT-4o-mini)
- Anthropic (Claude 3.5 Sonnet, Claude 3 Haiku)
- Google (Gemini 1.5 Pro, Gemini 1.5 Flash)
- OpenAIäº’æ›ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ

**å®Ÿè£…è¨­è¨ˆ**:
```typescript
interface LLMProvider {
  generateStructuredOutput<T>(
    schema: ZodSchema<T>,
    prompt: string,
    options?: LLMOptions
  ): Promise<T>;
}
```

**ä¿¡é ¼æ€§ã®ç¢ºä¿**:
- è‡ªå‹•ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼éšœå®³æ™‚ï¼‰
- æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã«ã‚ˆã‚‹å†è©¦è¡Œ
- ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã®è‡ªå‹•å¯¾å¿œ
- ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼å¥åº·ãƒã‚§ãƒƒã‚¯

**é€æ˜æ€§ã®æä¾›**:
- å‘¼ã³å‡ºã—ãƒ­ã‚°ã®è©³ç´°è¨˜éŒ²
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®åé›†
- ã‚¨ãƒ©ãƒ¼åŸå› ã®æ˜ç¢ºåŒ–

## ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è©•ä¾¡ã¨æ”¹å–„

### ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è©•ä¾¡æŒ‡æ¨™

**æ€§èƒ½è©•ä¾¡**:
- å®Ÿè¡Œæ™‚é–“ã¨ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨é‡
- æˆåŠŸç‡ã¨ã‚¨ãƒ©ãƒ¼ç‡
- å‡ºåŠ›å“è³ªã®ä¸€è²«æ€§

**æ”¹å–„æ–¹æ³•**:
- ãƒ­ã‚°åˆ†æã«ã‚ˆã‚‹ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ç‰¹å®š
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®ç›£è¦–
- ç¶™ç¶šçš„ãªæœ€é©åŒ–

### è©•ä¾¡ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…

**ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†**:
```typescript
interface AgentMetrics {
  methodType: ThinkingMethodType;
  executionTime: number;
  successRate: number;
  errorRate: number;
  averageConfidence: number;
  totalExecutions: number;
  lastExecuted: Date;
}

class MetricsCollector {
  private metrics: Map<ThinkingMethodType, AgentMetrics> = new Map();

  recordExecution(method: ThinkingMethodType, result: ThinkingResult) {
    const current = this.metrics.get(method) || this.initializeMetrics(method);
    
    current.executionTime = (current.executionTime + result.metadata.executionTime) / 2;
    current.totalExecutions++;
    current.lastExecuted = new Date();
    
    if (result.status === 'completed') {
      current.successRate = (current.successRate + 1) / current.totalExecutions;
      current.averageConfidence = (current.averageConfidence + result.confidence) / 2;
    } else {
      current.errorRate = (current.errorRate + 1) / current.totalExecutions;
    }
    
    this.metrics.set(method, current);
  }

  getMetrics(method: ThinkingMethodType): AgentMetrics | undefined {
    return this.metrics.get(method);
  }

  getAllMetrics(): AgentMetrics[] {
    return Array.from(this.metrics.values());
  }
}
```

**ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–**:
```typescript
class PerformanceMonitor {
  private metricsCollector: MetricsCollector;
  private alertThresholds: PerformanceThresholds;

  constructor(metricsCollector: MetricsCollector) {
    this.metricsCollector = metricsCollector;
    this.alertThresholds = {
      maxExecutionTime: 30000, // 30ç§’
      minSuccessRate: 0.8,     // 80%
      maxErrorRate: 0.2        // 20%
    };
  }

  checkPerformance(method: ThinkingMethodType): PerformanceAlert[] {
    const metrics = this.metricsCollector.getMetrics(method);
    if (!metrics) return [];

    const alerts: PerformanceAlert[] = [];

    if (metrics.executionTime > this.alertThresholds.maxExecutionTime) {
      alerts.push({
        type: 'slow_execution',
        method,
        value: metrics.executionTime,
        threshold: this.alertThresholds.maxExecutionTime
      });
    }

    if (metrics.successRate < this.alertThresholds.minSuccessRate) {
      alerts.push({
        type: 'low_success_rate',
        method,
        value: metrics.successRate,
        threshold: this.alertThresholds.minSuccessRate
      });
    }

    return alerts;
  }
}
```

**ç¶™ç¶šçš„æ”¹å–„**:
```typescript
class AgentOptimizer {
  private performanceMonitor: PerformanceMonitor;
  private logger: Logger;

  constructor(performanceMonitor: PerformanceMonitor, logger: Logger) {
    this.performanceMonitor = performanceMonitor;
    this.logger = logger;
  }

  async optimizeAgent(method: ThinkingMethodType): Promise<OptimizationResult> {
    const alerts = this.performanceMonitor.checkPerformance(method);
    
    if (alerts.length === 0) {
      return { optimized: false, reason: 'No performance issues detected' };
    }

    const optimizations: Optimization[] = [];

    for (const alert of alerts) {
      switch (alert.type) {
        case 'slow_execution':
          optimizations.push(await this.optimizeExecutionTime(method));
          break;
        case 'low_success_rate':
          optimizations.push(await this.optimizeSuccessRate(method));
          break;
      }
    }

    return {
      optimized: true,
      optimizations,
      performanceGain: this.calculatePerformanceGain(optimizations)
    };
  }

  private async optimizeExecutionTime(method: ThinkingMethodType): Promise<Optimization> {
    // å®Ÿè¡Œæ™‚é–“ã®æœ€é©åŒ–ãƒ­ã‚¸ãƒƒã‚¯
    return {
      type: 'execution_time',
      description: 'Optimized LLM prompt and reduced processing steps',
      expectedImprovement: 0.2
    };
  }

  private async optimizeSuccessRate(method: ThinkingMethodType): Promise<Optimization> {
    // æˆåŠŸç‡ã®æœ€é©åŒ–ãƒ­ã‚¸ãƒƒã‚¯
    return {
      type: 'success_rate',
      description: 'Improved error handling and retry logic',
      expectedImprovement: 0.15
    };
  }
}
```

### æ€è€ƒæ³•ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ç‰¹å®šã®æ€è€ƒãƒ‘ã‚¿ãƒ¼ãƒ³ã«ç‰¹åŒ–ã—ã€æ˜ç¢ºãªå…¥åŠ›ãƒ»å‡ºåŠ›ã‚’æŒã¤ã‚·ãƒ³ãƒ—ãƒ«ãªè¨­è¨ˆã§ã™ã€‚

### 1. AbductionAgentï¼ˆã‚¢ãƒ–ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼‰

**ç›®çš„**: é©šãã¹ãäº‹å®Ÿã‹ã‚‰æœ€ã‚‚å¯èƒ½æ€§ã®é«˜ã„èª¬æ˜ä»®èª¬ã‚’ç”Ÿæˆ

**é©ç”¨å ´é¢**: ãƒã‚°ã®åŸå› èª¿æŸ»ã€äº‹æ¥­æ©Ÿä¼šã®ç™ºè¦‹ã€å®Ÿé¨“çµæœã®è§£é‡ˆ

**å…¥åŠ›**:
```typescript
{
  surprisingFact: string;    // è¦³å¯Ÿã•ã‚ŒãŸé©šãã¹ãäº‹å®Ÿ
  context?: string;          // èƒŒæ™¯æƒ…å ±
  domain?: string;          // å¯¾è±¡ãƒ‰ãƒ¡ã‚¤ãƒ³
}
```

**å‡ºåŠ›**:
```typescript
{
  hypotheses: Array<{
    explanation: string;           // ä»®èª¬ã®èª¬æ˜
    plausibility: number;         // å¯èƒ½æ€§ï¼ˆ0-1ï¼‰
    testablePredictions: string[]; // æ¤œè¨¼å¯èƒ½ãªäºˆæ¸¬
  }>;
  recommendedNext: ThinkingMethodType[]; // æ¬¡ã®æ¨å¥¨æ€è€ƒæ³•
}
```

**æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ã®é€æ˜æ€§**:
1. äº‹å®Ÿã®åˆ†æã¨ç‰¹å¾´æŠ½å‡º
2. å¯èƒ½ãªèª¬æ˜ä»®èª¬ã®ç”Ÿæˆ
3. å„ä»®èª¬ã®å¦¥å½“æ€§è©•ä¾¡
4. æ¤œè¨¼æ–¹æ³•ã®ææ¡ˆ

### 2. LogicalAgentï¼ˆãƒ­ã‚¸ã‚«ãƒ«ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼‰

**ç›®çš„**: è«–ç‚¹ã‹ã‚‰çµè«–ã¸ã®è«–ç†çš„é“ç­‹ã‚’æ§‹ç¯‰

**é©ç”¨å ´é¢**: è¦ä»¶å®šç¾©ã€å„ªå…ˆé †ä½ä»˜ã‘ã€è¦‹ç©ã‚‚ã‚Šãƒ»è¨ˆç”»

**æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹**:
1. è«–ç‚¹ã®æ˜ç¢ºåŒ–
2. æ ¹æ‹ ã®æ•´ç†
3. è«–ç†çš„é“ç­‹ã®æ§‹ç¯‰
4. çµè«–ã®å¦¥å½“æ€§æ¤œè¨¼

### 3. CriticalAgentï¼ˆã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼‰

**ç›®çš„**: å‰æãƒ»è«–ç‚¹ãƒ»æ ¹æ‹ ã‚’ä½“ç³»çš„ã«æ¤œè¨¼

**é©ç”¨å ´é¢**: ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ã€è¦ä»¶å®šç¾©ã€ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°

**æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹**:
1. å‰æã®ç‰¹å®šã¨æ¤œè¨¼
2. è«–ç†ã®é£›èºã®ç‰¹å®š
3. ãƒã‚¤ã‚¢ã‚¹ã®æ¤œå‡º
4. ä»£æ›¿è§£ã®æ¤œè¨

### 4. MECEAgentï¼ˆMECEã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼‰

**ç›®çš„**: é …ç›®ã‚’æ¼ã‚Œãªãé‡è¤‡ãªãåˆ†é¡

**é©ç”¨å ´é¢**: å„ªå…ˆé †ä½ä»˜ã‘ã€ãƒ†ã‚¹ãƒˆè¨­è¨ˆã€ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°

**æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹**:
1. åˆ†é¡è»¸ã®è¨­å®š
2. å®Œå…¨æ€§ã®ç¢ºèª
3. æ’ä»–æ€§ã®ç¢ºèª
4. éšå±¤æ§‹é€ ã®æ§‹ç¯‰

### 5. DeductiveAgentï¼ˆæ¼”ç¹¹ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼‰

**ç›®çš„**: ä¸€èˆ¬çš„ãªåŸå‰‡ã‹ã‚‰å…·ä½“çš„ãªçµè«–ã‚’å°å‡º

**é©ç”¨å ´é¢**: ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆã€å®Ÿè£…ã€ãƒ†ã‚¹ãƒˆè¨­è¨ˆ

**æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹**:
1. ä¸€èˆ¬åŸå‰‡ã®é©ç”¨
2. ä¸‰æ®µè«–æ³•ã®æ§‹ç¯‰
3. çµè«–ã®è«–ç†çš„å°å‡º
4. å¦¥å½“æ€§ã®æ¤œè¨¼

### 6. InductiveAgentï¼ˆå¸°ç´ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼‰

**ç›®çš„**: å€‹åˆ¥äº‹ä¾‹ã‹ã‚‰å…±é€šãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç™ºè¦‹

**é©ç”¨å ´é¢**: ä¾¡å€¤ä»®èª¬ã€å®Ÿé¨“ã€ãƒ‡ãƒãƒƒã‚°

**æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹**:
1. äº‹ä¾‹ã®åé›†ã¨åˆ†æ
2. å…±é€šãƒ‘ã‚¿ãƒ¼ãƒ³ã®ç™ºè¦‹
3. ä¸€èˆ¬åŒ–ã®å°å‡º
4. çµ±è¨ˆçš„æ¤œè¨¼

### 7. PACAgentï¼ˆPACã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼‰

**ç›®çš„**: å‰æãƒ»ä»®å®šãƒ»çµè«–ã«åˆ†è§£ã—ã¦æ¤œè¨¼

**é©ç”¨å ´é¢**: ä»®èª¬åˆ†è§£ã€ãµã‚Šã‹ãˆã‚Š

**æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹**:
1. å‰æã®æ˜ç¢ºåŒ–
2. ä»®å®šã®ç‰¹å®š
3. çµè«–ã®æ¤œè¨¼
4. è«–ç†æ§‹é€ ã®åˆ†æ

### 8. MetaAgentï¼ˆãƒ¡ã‚¿ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼‰

**ç›®çš„**: æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹è‡ªä½“ã‚’è©•ä¾¡ãƒ»æ”¹å–„

**é©ç”¨å ´é¢**: ãµã‚Šã‹ãˆã‚Šã€è¦‹ç©ã‚‚ã‚Šãƒ»è¨ˆç”»ã€æ„æ€æ±ºå®š

**æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹**:
1. æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ã®åˆ†æ
2. æ”¹å–„ç‚¹ã®ç‰¹å®š
3. æœ€é©åŒ–ã®ææ¡ˆ
4. å­¦ç¿’ã®ä¿ƒé€²

### 9. DebateAgentï¼ˆãƒ‡ã‚£ãƒ™ãƒ¼ãƒˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼‰

**ç›®çš„**: è³›æˆãƒ»åå¯¾è«–ç‚¹ã§æ„æ€æ±ºå®šæ”¯æ´

**é©ç”¨å ´é¢**: æ„æ€æ±ºå®šã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ

**æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹**:
1. è³›æˆè«–ç‚¹ã®æ•´ç†
2. åå¯¾è«–ç‚¹ã®æ•´ç†
3. å¯¾ç«‹ç‚¹ã®æ˜ç¢ºåŒ–
4. ç·åˆåˆ¤æ–­ã®æ”¯æ´

### ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è©•ä¾¡æŒ‡æ¨™

**æ€§èƒ½è©•ä¾¡**:
- å®Ÿè¡Œæ™‚é–“ã¨ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨é‡
- æˆåŠŸç‡ã¨ã‚¨ãƒ©ãƒ¼ç‡
- å‡ºåŠ›å“è³ªã®ä¸€è²«æ€§

**æ”¹å–„æ–¹æ³•**:
- ãƒ­ã‚°åˆ†æã«ã‚ˆã‚‹ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ç‰¹å®š
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®ç›£è¦–
- ç¶™ç¶šçš„ãªæœ€é©åŒ–

## æ€è€ƒæˆ¦ç•¥

### å±€é¢åˆ¥æˆ¦ç•¥ãƒãƒƒãƒ”ãƒ³ã‚°

å„é–‹ç™ºå±€é¢ã«æœ€é©ãªæ€è€ƒæ³•ã®çµ„ã¿åˆã‚ã›ã‚’å®šç¾©ï¼š

| å±€é¢ | ä¸»è¦æ€è€ƒæ³• | ä½µç”¨æ€è€ƒæ³• | ç›®çš„ |
|------|------------|------------|------|
| business_exploration | abduction | inductive, deductive, meta | é©šãã‹ã‚‰ä»®èª¬å½¢æˆ |
| requirement_definition | logical | mece, critical | è«–ç‚¹â†’çµè«–ã®é“ç­‹ |
| value_hypothesis | inductive | critical | ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ä¸€èˆ¬åŒ– |
| architecture_design | deductive | debate | åŸå‰‡â†’è¨­è¨ˆçµè«– |
| prioritization | mece | logical | ç²’åº¦æƒãˆãƒ»é‡è¤‡æ’é™¤ |
| estimation_planning | logical | meta | å‰æâ†’åˆ†è§£â†’è¦‹ç© |
| implementation | deductive | critical | åŸå‰‡â†’å…·ä½“ã‚³ãƒ¼ãƒ‰ |
| debugging | abduction | deductive, inductive | å…†å€™â†’åŸå› ä»®èª¬ |
| refactoring | critical | mece, logical | å‰æãƒ»ä¾å­˜ã‚’ç–‘ã† |
| code_review | critical | deductive, mece | çµè«–â†”æ ¹æ‹ ã®æ¤œè¨¼ |
| test_design | deductive | mece, inductive | ä»•æ§˜â†’æ¡ä»¶å°å‡º |
| experimentation | inductive | critical | ãƒ‡ãƒ¼ã‚¿â†’åŠ¹æœä¸€èˆ¬åŒ– |
| decision_making | debate | meta | è³›å¦è«–ç‚¹ã®é¡•åœ¨åŒ– |
| retrospective | meta | logical, pac | æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹è¦‹ç›´ã— |
| hypothesis_breakdown | pac | critical | å‰æãƒ»ä»®å®šãƒ»çµè«–åˆ†è§£ |

### é»„é‡‘ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆGolden Patternï¼‰

**ç›®çš„**: æ¢ç´¢ã‹ã‚‰å®Ÿè£…ã¾ã§ã®çµ±åˆãƒ•ãƒ­ãƒ¼ã‚’æä¾›

**ã‚·ãƒ¼ã‚±ãƒ³ã‚¹**: abduction â†’ deductive â†’ inductive â†’ critical â†’ logical â†’ meta â†’ debate

**ç‰¹å¾´**:
- å„æ€è€ƒæ³•ã®å‡ºåŠ›ãŒæ¬¡ã®æ€è€ƒæ³•ã®å…¥åŠ›ã¨ãªã‚‹é€£é–æ§‹é€ 
- æ®µéšçš„ãªæ€è€ƒã®æ·±åŒ–
- åŒ…æ‹¬çš„ãªå•é¡Œè§£æ±ºã‚¢ãƒ—ãƒ­ãƒ¼ãƒ

## å‹å®‰å…¨æ€§ã¨ã‚¹ã‚­ãƒ¼ãƒè¨­è¨ˆ

### ã‚¹ã‚­ãƒ¼ãƒè¨­è¨ˆã®åŸå‰‡

**ã‚·ãƒ³ãƒ—ãƒ«ãªè¨­è¨ˆ**: å¿…è¦æœ€å°é™ã®å‹å®šç¾©ã§æœ€å¤§ã®å‹å®‰å…¨æ€§ã‚’ç¢ºä¿

**é€æ˜æ€§**: å„ã‚¹ã‚­ãƒ¼ãƒã®ç›®çš„ã¨åˆ¶ç´„ã‚’æ˜ç¢ºã«å®šç¾©

**ä¿¡é ¼æ€§**: å®Ÿè¡Œæ™‚å‹ãƒã‚§ãƒƒã‚¯ã«ã‚ˆã‚‹å …ç‰¢æ€§ã®ä¿è¨¼

### åŸºæœ¬å‹å®šç¾©

```typescript
// æ€è€ƒæ³•ã®ç¨®é¡
type ThinkingMethodType = 
  | 'abduction' | 'logical' | 'critical' | 'mece' 
  | 'deductive' | 'inductive' | 'pac' | 'meta' | 'debate';

// é–‹ç™ºå±€é¢
type DevelopmentPhase = 
  | 'business_exploration' | 'requirement_definition' 
  | 'value_hypothesis' | 'architecture_design'
  | 'prioritization' | 'estimation_planning'
  | 'implementation' | 'debugging' | 'refactoring'
  | 'code_review' | 'test_design' | 'experimentation'
  | 'decision_making' | 'retrospective' | 'hypothesis_breakdown';
```

### æ€è€ƒçµæœã®å‹å®šç¾©

```typescript
// å˜ä¸€æ€è€ƒçµæœ
interface ThinkingResult {
  method: ThinkingMethodType;
  status: 'pending' | 'in_progress' | 'completed' | 'failed';
  input: Record<string, unknown>;
  output?: Record<string, unknown>;
  confidence: number; // 0-1
  reasoning: string;
  nextRecommendations?: ThinkingMethodType[];
  metadata?: Record<string, unknown>;
}

// çµ±åˆæ€è€ƒçµæœ
interface IntegratedThinkingResult {
  phase: DevelopmentPhase;
  primaryMethod: ThinkingMethodType;
  secondaryMethods: ThinkingMethodType[];
  results: ThinkingResult[];
  synthesis: string;
  actionItems: string[];
  confidence: number;
  nextSteps: string[];
}
```

### å„æ€è€ƒæ³•ã®ã‚¹ã‚­ãƒ¼ãƒ

å„æ€è€ƒæ³•ã¯å°‚ç”¨ã®å…¥å‡ºåŠ›ã‚¹ã‚­ãƒ¼ãƒã‚’æŒã¡ã€Zodã«ã‚ˆã‚‹å®Ÿè¡Œæ™‚æ¤œè¨¼ã‚’å®Ÿè£…ï¼š

- `AbductionInput` / `AbductionOutput`
- `LogicalInput` / `LogicalOutput`
- `CriticalInput` / `CriticalOutput`
- `MECEInput` / `MECEOutput`
- `DeductiveInput` / `DeductiveOutput`
- `InductiveInput` / `InductiveOutput`
- `PACInput` / `PACOutput`
- `MetaInput` / `MetaOutput`
- `DebateInput` / `DebateOutput`

## MCPçµ±åˆ

### MCPã‚µãƒ¼ãƒãƒ¼è¨­è¨ˆ

**ç›®çš„**: AIé–‹ç™ºç’°å¢ƒã¨ã®çµ±åˆã‚’æä¾›ã—ã€æ€è€ƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ãƒ„ãƒ¼ãƒ«ã¨ã—ã¦åˆ©ç”¨å¯èƒ½ã«ã™ã‚‹

**æä¾›ãƒ„ãƒ¼ãƒ«**:
- `process-phase`: å±€é¢åˆ¥çµ±åˆæ€è€ƒãƒ—ãƒ­ã‚»ã‚¹
- `process-golden-pattern`: é»„é‡‘ãƒ‘ã‚¿ãƒ¼ãƒ³å®Ÿè¡Œ
- `process-single-method`: å˜ä¸€æ€è€ƒæ³•å®Ÿè¡Œ
- `list-thinking-methods`: æ€è€ƒæ³•ä¸€è¦§å–å¾—
- `get-phase-recommendations`: å±€é¢åˆ¥æ¨å¥¨å–å¾—

**è¨­å®šä¾‹**:
```json
{
  "mcpServers": {
    "thinking-agents": {
      "command": "npx",
      "args": ["@53able/conflux", "server"],
      "env": {
        "OPENAI_API_KEY": "sk-proj-...",
        "DEFAULT_LLM_PROVIDER": "openai"
      }
    }
  }
}
```

**é€æ˜æ€§ã®ç¢ºä¿**:
- å„ãƒ„ãƒ¼ãƒ«ã®å‹•ä½œãƒ­ã‚°ã‚’è©³ç´°ã«è¨˜éŒ²
- ã‚¨ãƒ©ãƒ¼ã®åŸå› ã¨è§£æ±ºæ–¹æ³•ã‚’æ˜ç¢ºã«æç¤º
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®æä¾›

## CLIè¨­è¨ˆ

### ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

**ç›®çš„**: é–‹ç™ºè€…ãŒæ€è€ƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç°¡å˜ã«åˆ©ç”¨ã§ãã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›

**ã‚·ãƒ³ãƒ—ãƒ«ãªè¨­è¨ˆ**:
```bash
# å±€é¢åˆ¥æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹
conflux phase debugging '{"issue": "APIã‚¨ãƒ©ãƒ¼", "context": "DBå•é¡Œ"}'

# é»„é‡‘ãƒ‘ã‚¿ãƒ¼ãƒ³å®Ÿè¡Œ
conflux golden '{"problem": "ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ"}'

# å˜ä¸€æ€è€ƒæ³•
conflux single critical '{"claim": "ã“ã®å®Ÿè£…ã§ååˆ†"}'

# æ€è€ƒæ³•ä¸€è¦§
conflux list

# å±€é¢åˆ¥æ¨å¥¨
conflux recommend debugging

# MCPã‚µãƒ¼ãƒãƒ¼èµ·å‹•
conflux server
```

**é€æ˜æ€§ã®æä¾›**:
- å„ã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œãƒ­ã‚°ã‚’è©³ç´°ã«è¡¨ç¤º
- ã‚¨ãƒ©ãƒ¼æ™‚ã®è§£æ±ºæ–¹æ³•ã‚’æç¤º
- å®Ÿè¡Œæ™‚é–“ã¨ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨é‡ã®è¡¨ç¤º

## å“è³ªä¿è¨¼

### å‹å®‰å…¨æ€§ã®ç¢ºä¿

**TypeScriptå³å¯†ãƒ¢ãƒ¼ãƒ‰**:
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "noImplicitAny": true,
    "exactOptionalPropertyTypes": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  }
}
```

**ESLintè¨­å®š**:
- anyå‹å®Œå…¨ç¦æ­¢
- æœªä½¿ç”¨å¤‰æ•°æ¤œå‡º
- ä¸€è²«ã—ãŸå‘½åè¦å‰‡
- TypeScript v5.6å¯¾å¿œ
- ESLint v9å¯¾å¿œ

### ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

**ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ†ã‚¹ãƒˆè¨­è¨ˆ**:
- å˜ä½“ãƒ†ã‚¹ãƒˆï¼ˆå„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼‰
- çµ±åˆãƒ†ã‚¹ãƒˆï¼ˆã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼‰
- E2Eãƒ†ã‚¹ãƒˆï¼ˆCLIãƒ»MCPï¼‰

**ä¿¡é ¼æ€§ã®ç¢ºä¿**:
- è‡ªå‹•ãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œ
- ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ
- ç¶™ç¶šçš„ã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

## æ‹¡å¼µæ€§

### ã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è¿½åŠ 

**ã‚·ãƒ³ãƒ—ãƒ«ãªæ‹¡å¼µè¨­è¨ˆ**:
```typescript
class CustomThinkingAgent extends BaseThinkingAgent {
  readonly capability: AgentCapability = {
    methodType: 'custom',
    description: 'ã‚«ã‚¹ã‚¿ãƒ æ€è€ƒæ³•',
    applicablePhases: ['implementation'],
    requiredInputSchema: z.object({ /* ã‚¹ã‚­ãƒ¼ãƒ */ }),
    outputSchema: z.object({ /* å‡ºåŠ›ã‚¹ã‚­ãƒ¼ãƒ */ }),
    combinationSynergies: ['critical', 'logical'],
  };
  
  protected async executeLLMThinking(input: unknown, context: AgentContext) {
    // ã‚«ã‚¹ã‚¿ãƒ ãƒ­ã‚¸ãƒƒã‚¯å®Ÿè£…
  }
}
```

### æ–°è¦ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã®è¿½åŠ 

**çµ±ä¸€ã•ã‚ŒãŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹**:
```typescript
// ã‚«ã‚¹ã‚¿ãƒ LLMãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã®è¿½åŠ 
globalLLMManager.registerProvider('custom', {
  type: 'openai-compatible',
  baseURL: 'https://api.custom-llm.com/v1',
  model: 'custom-model',
  apiKey: 'custom-key',
});
```

**é€æ˜æ€§ã®ç¢ºä¿**:
- æ‹¡å¼µãƒã‚¤ãƒ³ãƒˆã®æ˜ç¢ºãªå®šç¾©
- ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆåŒ–ã•ã‚ŒãŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
- ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã®æä¾›

## ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¨ä¿¡é ¼æ€§

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

**ä¸¦åˆ—å‡¦ç†**:
- ç‹¬ç«‹ã—ãŸæ€è€ƒæ³•ã¯ä¸¦åˆ—å®Ÿè¡Œå¯èƒ½
- LLMå‘¼ã³å‡ºã—ã®æœ€é©åŒ–
- ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥

**ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†**:
- ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼é¸æŠæœ€é©åŒ–
- ãƒ¬ãƒ¼ãƒˆåˆ¶é™å¯¾å¿œ
- ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡æœ€é©åŒ–

### ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

**è‡ªå‹•å¾©æ—§æ©Ÿèƒ½**:
- ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼
- æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã«ã‚ˆã‚‹å†è©¦è¡Œ
- è©³ç´°ãªã‚¨ãƒ©ãƒ¼ãƒ­ã‚°

**ä¿¡é ¼æ€§ã®ç¢ºä¿**:
- ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼å¥åº·ãƒã‚§ãƒƒã‚¯
- è‡ªå‹•å¾©æ—§ãƒ¡ã‚«ãƒ‹ã‚ºãƒ 
- ã‚°ãƒ¬ãƒ¼ã‚¹ãƒ•ãƒ«ãƒ‡ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³

## ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

### APIã‚­ãƒ¼ç®¡ç†

**ã‚»ã‚­ãƒ¥ã‚¢ãªè¨­å®š**:
- ç’°å¢ƒå¤‰æ•°ãƒ™ãƒ¼ã‚¹ã®è¨­å®š
- ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼å›ºæœ‰ã®èªè¨¼
- ã‚»ã‚­ãƒ¥ã‚¢ãªè¨­å®šç®¡ç†

### ãƒ‡ãƒ¼ã‚¿å‡¦ç†

**ãƒ‡ãƒ¼ã‚¿ä¿è­·**:
- å…¥åŠ›æ¤œè¨¼ï¼ˆZodï¼‰
- å‡ºåŠ›ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
- æ©Ÿå¯†æƒ…å ±ã®ä¿è­·

## Dockerç’°å¢ƒã§ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### ã‚³ãƒ³ãƒ†ãƒŠåŒ–æˆ¦ç•¥

**ç›®çš„**: æœ¬ç•ªç’°å¢ƒã§ã®ä½¿ç”¨ã«æœ€é©åŒ–ã•ã‚ŒãŸDockerã‚³ãƒ³ãƒ†ãƒŠã‚’æä¾›

**ã‚·ãƒ³ãƒ—ãƒ«ãªè¨­è¨ˆ**:
```dockerfile
# ãƒ“ãƒ«ãƒ‰ã‚¹ãƒ†ãƒ¼ã‚¸
FROM node:20-alpine AS builder
RUN npm install -g pnpm
WORKDIR /app
COPY package.json pnpm-lock.yaml ./
RUN pnpm install --frozen-lockfile
COPY . .
RUN pnpm run build

# æœ¬ç•ªã‚¹ãƒ†ãƒ¼ã‚¸
FROM node:20-alpine AS production
RUN npm install -g pnpm
WORKDIR /app
COPY package.json pnpm-lock.yaml ./
RUN pnpm install --frozen-lockfile --prod
COPY --from=builder /app/dist ./dist
RUN addgroup -g 1001 -S nodejs && adduser -S conflux -u 1001
RUN chown -R conflux:nodejs /app
USER conflux
CMD ["node", "dist/mcp/server.js"]
```

**ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­è¨ˆ**:
- érootãƒ¦ãƒ¼ã‚¶ãƒ¼å®Ÿè¡Œ
- æœ€å°æ¨©é™ã®åŸå‰‡
- Alpine Linuxãƒ™ãƒ¼ã‚¹
- ãƒãƒ«ãƒã‚¹ãƒ†ãƒ¼ã‚¸ãƒ“ãƒ«ãƒ‰

**Docker Composeè¨­å®š**:
```yaml
version: '3.8'
services:
  mcp-server:
    build: 
      context: .
      target: production
    environment:
      - NODE_ENV=production
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      - DEFAULT_LLM_PROVIDER=${DEFAULT_LLM_PROVIDER:-openai}
    stdin_open: true
    tty: true
    restart: unless-stopped
```

### ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³

**å˜ä¸€ã‚³ãƒ³ãƒ†ãƒŠãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆ**:
```bash
# ç›´æ¥å®Ÿè¡Œ
docker run -it --rm \
  -e OPENAI_API_KEY=your_key \
  conflux-mcp

# ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å®Ÿè¡Œ
docker run -d --name conflux-mcp \
  -e OPENAI_API_KEY=your_key \
  conflux-mcp
```

**Docker Composeãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆ**:
```bash
# é–‹ç™ºç’°å¢ƒ
docker compose --env-file .env.docker up --build

# æœ¬ç•ªç’°å¢ƒ
docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d
```

**Kubernetesãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆ**:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: conflux-mcp
spec:
  replicas: 1
  selector:
    matchLabels:
      app: conflux-mcp
  template:
    metadata:
      labels:
        app: conflux-mcp
    spec:
      containers:
      - name: conflux-mcp
        image: conflux-mcp:latest
        env:
        - name: OPENAI_API_KEY
          valueFrom:
            secretKeyRef:
              name: conflux-secrets
              key: openai-api-key
        stdin: true
        tty: true
```

### ãƒ­ã‚°ã¨ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°

**Winstonãƒ­ã‚°è¨­å®š**:
```typescript
const logger = createLogger({
  level: 'info',
  format: format.combine(
    format.timestamp(),
    format.errors({ stack: true }),
    format.json()
  ),
  transports: [
    new transports.Console(),
    new transports.File({ filename: 'mcp-server.log' })
  ]
});
```

**ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯**:
```yaml
healthcheck:
  test: ["CMD", "node", "-e", "process.exit(0)"]
  interval: 30s
  timeout: 10s
  retries: 3
```

## ä»˜éŒ²

### ä»˜éŒ²1: ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿéš›ã®ä½¿ç”¨ä¾‹

#### ã‚«ã‚¹ã‚¿ãƒãƒ¼ã‚µãƒãƒ¼ãƒˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

**ã‚·ãƒŠãƒªã‚ª**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ã®ãƒ­ã‚°ã‚¤ãƒ³å•é¡Œã®å ±å‘Šã‚’åˆ†æ

```typescript
// ãƒã‚°å ±å‘Šã®åˆ†æ
const result = await orchestrator.processPhase('debugging', {
  issue: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ­ã‚°ã‚¤ãƒ³ã§ããªã„',
  context: 'ãƒ¢ãƒã‚¤ãƒ«ã‚¢ãƒ—ãƒªã§ç™ºç”Ÿ',
  domain: 'èªè¨¼ã‚·ã‚¹ãƒ†ãƒ '
});

// å‡ºåŠ›ä¾‹
{
  hypotheses: [
    {
      explanation: 'ãƒ¢ãƒã‚¤ãƒ«ã‚¢ãƒ—ãƒªã®èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ãŒæœŸé™åˆ‡ã‚Œ',
      plausibility: 0.8,
      testablePredictions: ['ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æœŸé™ã‚’ç¢ºèª', 'å†èªè¨¼ãƒ•ãƒ­ãƒ¼ã‚’ãƒ†ã‚¹ãƒˆ']
    },
    {
      explanation: 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã®å•é¡Œã§APIå‘¼ã³å‡ºã—ãŒå¤±æ•—',
      plausibility: 0.6,
      testablePredictions: ['ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚’ç¢ºèª', 'APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®å¿œç­”ã‚’ãƒ†ã‚¹ãƒˆ']
    }
  ],
  recommendedNext: ['deductive', 'critical']
}
```

**æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—**: æ¼”ç¹¹çš„æ€è€ƒã§ä»®èª¬ã‚’æ¤œè¨¼
```typescript
const verification = await orchestrator.processSingleMethod('deductive', {
  hypothesis: 'èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ãŒæœŸé™åˆ‡ã‚Œ',
  evidence: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæœ€å¾Œã«ãƒ­ã‚°ã‚¤ãƒ³ã—ãŸã®ã¯1é€±é–“å‰',
  rule: 'ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æœŸé™ã¯24æ™‚é–“'
});
```

#### ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

**ã‚·ãƒŠãƒªã‚ª**: ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆã®æ”¯æ´

```typescript
// ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆã®æ”¯æ´
const result = await orchestrator.processPhase('architecture_design', {
  requirements: 'ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹åŒ–ãŒå¿…è¦',
  constraints: 'ãƒ¬ã‚¬ã‚·ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ã¨ã®çµ±åˆ',
  domain: 'ECã‚µã‚¤ãƒˆ'
});

// å‡ºåŠ›ä¾‹
{
  architecture: {
    pattern: 'Strangler Fig Pattern',
    services: ['User Service', 'Product Service', 'Order Service'],
    integration: 'API Gateway + Event Sourcing',
    migration: 'æ®µéšçš„ãªç§»è¡Œæˆ¦ç•¥'
  },
  reasoning: 'ãƒ¬ã‚¬ã‚·ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ã‚’æ®µéšçš„ã«ç½®ãæ›ãˆã‚‹ã“ã¨ã§ã€ãƒªã‚¹ã‚¯ã‚’æœ€å°åŒ–',
  confidence: 0.85
}
```

#### ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

**ã‚·ãƒŠãƒªã‚ª**: æ©Ÿèƒ½ã®å„ªå…ˆé †ä½ä»˜ã‘

```typescript
const result = await orchestrator.processPhase('prioritization', {
  features: [
    { name: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼', impact: 'high', effort: 'medium' },
    { name: 'å•†å“æ¤œç´¢', impact: 'high', effort: 'low' },
    { name: 'ãƒ¬ã‚³ãƒ¡ãƒ³ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³', impact: 'medium', effort: 'high' }
  ],
  constraints: 'ãƒªãƒªãƒ¼ã‚¹ã¾ã§2é€±é–“'
});

// å‡ºåŠ›ä¾‹
{
  prioritized: [
    { feature: 'å•†å“æ¤œç´¢', priority: 1, reason: 'é«˜ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆãƒ»ä½å·¥æ•°' },
    { feature: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼', priority: 2, reason: 'é«˜ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆãƒ»ä¸­å·¥æ•°' },
    { feature: 'ãƒ¬ã‚³ãƒ¡ãƒ³ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³', priority: 3, reason: 'ä¸­ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆãƒ»é«˜å·¥æ•°' }
  ],
  reasoning: 'æ™‚é–“åˆ¶ç´„ã‚’è€ƒæ…®ã—ã€ROIã®é«˜ã„æ©Ÿèƒ½ã‚’å„ªå…ˆ'
}
```

### ä»˜éŒ²2: ãƒ„ãƒ¼ãƒ«ã®è¨­è¨ˆã¨çµ±åˆ

#### MCPãƒ„ãƒ¼ãƒ«ã®è¨­è¨ˆåŸå‰‡

1. **æ˜ç¢ºãªç›®çš„**: å„ãƒ„ãƒ¼ãƒ«ã®å½¹å‰²ã‚’æ˜ç¢ºã«å®šç¾©
2. **ä¸€è²«ã—ãŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹**: çµ±ä¸€ã•ã‚ŒãŸãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å½¢å¼
3. **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**: é©åˆ‡ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨å¾©æ—§æ–¹æ³•
4. **ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆåŒ–**: ä½¿ç”¨ä¾‹ã¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è©³ç´°èª¬æ˜

#### ãƒ„ãƒ¼ãƒ«çµ±åˆã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

**ãƒ„ãƒ¼ãƒ«å®šç¾©ã®ä¾‹**:
```typescript
const processPhaseTool = {
  name: 'process-phase',
  description: 'å±€é¢åˆ¥çµ±åˆæ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ã‚’å®Ÿè¡Œ',
  inputSchema: {
    type: 'object',
    properties: {
      phase: { 
        type: 'string', 
        enum: Object.values(DevelopmentPhase),
        description: 'å®Ÿè¡Œã™ã‚‹é–‹ç™ºå±€é¢'
      },
      input: { 
        type: 'object',
        description: 'æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ã¸ã®å…¥åŠ›ãƒ‡ãƒ¼ã‚¿'
      }
    },
    required: ['phase', 'input']
  },
  outputSchema: {
    type: 'object',
    properties: {
      results: { type: 'array' },
      synthesis: { type: 'string' },
      actionItems: { type: 'array' },
      confidence: { type: 'number' }
    }
  }
};
```

**ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**:
```typescript
class MCPToolHandler {
  async handleToolCall(toolName: string, parameters: unknown): Promise<ToolResult> {
    try {
      const result = await this.executeTool(toolName, parameters);
      return {
        success: true,
        data: result,
        metadata: {
          executionTime: result.metadata.executionTime,
          timestamp: new Date().toISOString()
        }
      };
    } catch (error) {
      return {
        success: false,
        error: {
          type: error.constructor.name,
          message: error.message,
          stack: error.stack
        },
        suggestions: this.generateErrorSuggestions(error)
      };
    }
  }

  private generateErrorSuggestions(error: Error): string[] {
    if (error.message.includes('Invalid phase')) {
      return [
        'æœ‰åŠ¹ãªå±€é¢ã‚’æŒ‡å®šã—ã¦ãã ã•ã„',
        'åˆ©ç”¨å¯èƒ½ãªå±€é¢: business_exploration, requirement_definition, ...'
      ];
    }
    if (error.message.includes('Invalid input')) {
      return [
        'å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã®å½¢å¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„',
        'ã‚¹ã‚­ãƒ¼ãƒã«å¾“ã£ãŸæ­£ã—ã„å½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„'
      ];
    }
    return ['ã‚¨ãƒ©ãƒ¼ã®è©³ç´°ã‚’ç¢ºèªã—ã€å…¥åŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å†ç¢ºèªã—ã¦ãã ã•ã„'];
  }
}
```

### ä»˜éŒ²3: å®Ÿè£…ã‚¬ã‚¤ãƒ‰

#### æ–°ã—ã„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è¿½åŠ æ‰‹é †

1. **ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¯ãƒ©ã‚¹ã®ä½œæˆ**:
```typescript
class NewThinkingAgent extends BaseThinkingAgent {
  readonly capability: AgentCapability = {
    methodType: 'new_method',
    description: 'æ–°ã—ã„æ€è€ƒæ³•',
    applicablePhases: ['implementation', 'debugging'],
    requiredInputSchema: z.object({
      problem: z.string(),
      context: z.string().optional()
    }),
    outputSchema: z.object({
      solution: z.string(),
      confidence: z.number().min(0).max(1),
      reasoning: z.string()
    }),
    combinationSynergies: ['critical', 'logical']
  };

  protected async executeLLMThinking(input: unknown, context: AgentContext) {
    // æ–°ã—ã„æ€è€ƒæ³•ã®å®Ÿè£…
    const prompt = this.buildPrompt(input);
    return await this.llmProvider.generateStructuredOutput(
      this.capability.outputSchema,
      prompt
    );
  }

  private buildPrompt(input: unknown): string {
    // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®æ§‹ç¯‰ãƒ­ã‚¸ãƒƒã‚¯
    return `æ–°ã—ã„æ€è€ƒæ³•ã‚’é©ç”¨ã—ã¦å•é¡Œã‚’è§£æ±ºã—ã¦ãã ã•ã„...`;
  }
}
```

2. **ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ç™»éŒ²**:
```typescript
// ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼ã«ç™»éŒ²
orchestrator.registerAgent(new NewThinkingAgent(llmProvider, logger));

// å±€é¢åˆ¥æˆ¦ç•¥ã«è¿½åŠ 
orchestrator.addPhaseStrategy('implementation', {
  primaryMethod: 'new_method',
  secondaryMethods: ['critical', 'logical']
});
```

3. **ãƒ†ã‚¹ãƒˆã®ä½œæˆ**:
```typescript
describe('NewThinkingAgent', () => {
  it('should generate valid output for valid input', async () => {
    const agent = new NewThinkingAgent(mockLLMProvider, mockLogger);
    const input = { problem: 'ãƒ†ã‚¹ãƒˆå•é¡Œ', context: 'ãƒ†ã‚¹ãƒˆã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ' };
    
    const result = await agent.think(input, { methodType: 'new_method' });
    
    expect(result.status).toBe('completed');
    expect(result.output).toMatchSchema(agent.capability.outputSchema);
    expect(result.confidence).toBeGreaterThan(0);
  });
});
```

## ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### ã‚ˆãã‚ã‚‹å•é¡Œã¨è§£æ±ºæ–¹æ³•

#### 1. LLMãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã®æ¥ç¶šã‚¨ãƒ©ãƒ¼

**å•é¡Œ**: APIã‚­ãƒ¼ãŒç„¡åŠ¹ã¾ãŸã¯è¨­å®šã•ã‚Œã¦ã„ãªã„
```
Error: OpenAI API key is required
```

**è§£æ±ºæ–¹æ³•**:
```bash
# ç’°å¢ƒå¤‰æ•°ã®è¨­å®š
export OPENAI_API_KEY="sk-proj-..."
export ANTHROPIC_API_KEY="sk-ant-..."
export GOOGLE_GENERATIVE_AI_API_KEY="AIza..."

# ã¾ãŸã¯ .env ãƒ•ã‚¡ã‚¤ãƒ«ã®ä½œæˆ
echo "OPENAI_API_KEY=sk-proj-..." > .env
echo "DEFAULT_LLM_PROVIDER=openai" >> .env
```

#### 2. ã‚¹ã‚­ãƒ¼ãƒæ¤œè¨¼ã‚¨ãƒ©ãƒ¼

**å•é¡Œ**: LLMã®å‡ºåŠ›ãŒæœŸå¾…ã•ã‚Œã‚‹ã‚¹ã‚­ãƒ¼ãƒã¨ä¸€è‡´ã—ãªã„
```
Error: Schema validation failed: Expected string, received number
```

**è§£æ±ºæ–¹æ³•**:
```typescript
// ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®æ”¹å–„
const systemPrompt = `ã‚ãªãŸã¯${this.capability.methodType}æ€è€ƒã®å°‚é–€å®¶ã§ã™ã€‚
å¿…ãšä»¥ä¸‹ã®JSONå½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ï¼š
${this.generateSchemaExample(this.capability.outputSchema)}`;

// æ¸©åº¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®èª¿æ•´
const result = await this.callLLMWithStructuredOutput(
  schema,
  systemPrompt,
  userPrompt,
  context,
  { temperature: 0.1 } // ã‚ˆã‚Šä½ã„æ¸©åº¦ã§ä¸€è²«æ€§ã‚’å‘ä¸Š
);
```

#### 3. ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®Ÿè¡Œã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ

**å•é¡Œ**: æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ãŒé•·æ™‚é–“å®Ÿè¡Œã•ã‚Œã‚‹
```
Error: Agent execution timeout after 30000ms
```

**è§£æ±ºæ–¹æ³•**:
```typescript
// ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šã®èª¿æ•´
const context: AgentContext = {
  llmProvider: globalLLMManager.getProvider(),
  sessionId: 'session-001',
  metadata: {
    timeout: 60000, // 60ç§’ã«å»¶é•·
    maxRetries: 2   // å†è©¦è¡Œå›æ•°ã‚’å‰Šæ¸›
  }
};
```

#### 4. MCPã‚µãƒ¼ãƒãƒ¼æ¥ç¶šã‚¨ãƒ©ãƒ¼

**å•é¡Œ**: MCPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã§ããªã„
```
Error: Failed to connect to MCP server
```

**è§£æ±ºæ–¹æ³•**:
```bash
# ã‚µãƒ¼ãƒãƒ¼ã®èµ·å‹•ç¢ºèª
npx @53able/conflux server --verbose

# ãƒãƒ¼ãƒˆã®ç¢ºèª
netstat -an | grep 3000

# ãƒ­ã‚°ã®ç¢ºèª
tail -f mcp-server.log
```

#### 5. ãƒ¡ãƒ¢ãƒªä¸è¶³ã‚¨ãƒ©ãƒ¼

**å•é¡Œ**: å¤§é‡ã®æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹å®Ÿè¡Œã§ãƒ¡ãƒ¢ãƒªä¸è¶³
```
Error: JavaScript heap out of memory
```

**è§£æ±ºæ–¹æ³•**:
```bash
# Node.jsã®ãƒ¡ãƒ¢ãƒªåˆ¶é™ã‚’å¢—åŠ 
export NODE_OPTIONS="--max-old-space-size=4096"

# ã¾ãŸã¯å®Ÿè¡Œæ™‚ã«æŒ‡å®š
node --max-old-space-size=4096 dist/mcp/server.js
```

### ãƒ‡ãƒãƒƒã‚°ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

#### 1. è©³ç´°ãƒ­ã‚°ã®æœ‰åŠ¹åŒ–

```typescript
// ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã®è¨­å®š
Logger.setLevel('debug');

// è©³ç´°ãªå®Ÿè¡Œãƒ­ã‚°ã®å–å¾—
const result = await orchestrator.processPhase('debugging', input, {
  llmProvider: globalLLMManager.getProvider(),
  sessionId: 'debug-session',
  metadata: {
    logLevel: 'detailed',
    includeReasoning: true,
    trackSteps: true
  }
});
```

#### 2. ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å€‹åˆ¥ãƒ†ã‚¹ãƒˆ

```typescript
// å˜ä¸€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ãƒ†ã‚¹ãƒˆ
const abductionAgent = new AbductionAgent();
const testInput = {
  surprisingFact: 'ãƒ†ã‚¹ãƒˆç”¨ã®é©šãã®äº‹å®Ÿ',
  context: 'ãƒ†ã‚¹ãƒˆã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ'
};

try {
  const result = await abductionAgent.think(testInput, context);
  console.log('Success:', result);
} catch (error) {
  console.error('Error:', error);
}
```

#### 3. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–

```typescript
// å®Ÿè¡Œæ™‚é–“ã®æ¸¬å®š
const startTime = Date.now();
const result = await orchestrator.processPhase(phase, input, context);
const executionTime = Date.now() - startTime;

console.log(`Execution time: ${executionTime}ms`);
console.log(`Confidence: ${result.confidence}`);
console.log(`Status: ${result.status}`);
```

### ã‚µãƒãƒ¼ãƒˆã¨ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£

- **GitHub Issues**: [https://github.com/53able/conflux/issues](https://github.com/53able/conflux/issues)
- **Discussions**: [https://github.com/53able/conflux/discussions](https://github.com/53able/conflux/discussions)
- **Documentation**: [https://github.com/53able/conflux/wiki](https://github.com/53able/conflux/wiki)

## ä»Šå¾Œã®æ‹¡å¼µæ–¹å‘

1. **æ–°è¦æ€è€ƒæ³•ã®è¿½åŠ **
2. **AIãƒ¢ãƒ‡ãƒ«ã®é€²åŒ–ã¸ã®å¯¾å¿œ**
3. **å¤šè¨€èªã‚µãƒãƒ¼ãƒˆ**
4. **å¯è¦–åŒ–æ©Ÿèƒ½**
5. **å­¦ç¿’æ©Ÿèƒ½ã®è¿½åŠ **
6. **Kubernetesãƒã‚¤ãƒ†ã‚£ãƒ–ã‚µãƒãƒ¼ãƒˆ**
7. **ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹åŒ–**

---

ã“ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¯ã€Building effective agentsã®åŸå‰‡ã«åŸºã¥ã„ã¦è¨­è¨ˆã•ã‚ŒãŸã€ã‚·ãƒ³ãƒ—ãƒ«ã§é€æ˜æ€§ãŒé«˜ãã€ä¿¡é ¼æ€§ã®é«˜ã„ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚é–‹ç™ºãƒ—ãƒ­ã‚»ã‚¹ã®å„å±€é¢ã§æœ€é©ãªæ€è€ƒæ”¯æ´ã‚’æä¾›ã—ã€AIé–‹ç™ºç’°å¢ƒã¨ã®çµ±åˆã‚’å®Ÿç¾ã—ã¾ã™ã€‚
